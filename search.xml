<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>错误监控</title>
    <url>/2020/04/16/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>代码质量管理其实就是错误监控及代码检查。</p>
<a id="more"></a>

<h1 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h1><h2 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h2><ol>
<li>即时运行错误：代码错误</li>
<li>资源加载错误</li>
</ol>
<h2 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h2><ol>
<li><p>即时错误的捕获方式</p>
<ol>
<li><p>try..catch</p>
</li>
<li><p>window.onerror</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>,funtion(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'捕获'</span>，e)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>资源加载错误</p>
<ol>
<li>object.onerror</li>
<li>performance.getEntries()</li>
<li>Error事件捕获</li>
<li>跨域错误捕获<ol>
<li>错误提示<br> Script error</li>
<li>处理方式<br> 在script标签上增加crossorigin<br> 设置js资源响应头Axxess-COntrol-Allow-Origin:*</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h2><ol>
<li><p>采用ajax通信方式上报</p>
</li>
<li><p>利用Image对象上报</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src =<span class="string">'http://baidu.com/testjk?r=tksjk'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>js运行机制</title>
    <url>/2020/04/16/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>js是单线程，任务分成同步任务、异步任务。先执行同步任务，在执行异步任务。异步任务通过Event-loop实现。同步任务没有执行完成，异步队列不会执行。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 3 2</span><br><span class="line"></span><br><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(3)</span><br><span class="line">&#x2F;&#x2F; 1 while同步任务，while不断的去循环</span><br><span class="line"></span><br><span class="line">for(var i &#x3D; 0; i &lt; 4; i++)&#123;</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		console.log(i)</span><br><span class="line">	&#125;,1000)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 4 for是一个同步任务。</span><br><span class="line">&#x2F;&#x2F; 异步队列放入时间和执行的时间。setTimeout会等待一秒然后再将函数体放入到异步任务。</span><br></pre></td></tr></table></figure>

<h1 id="任务队列和Event-loop"><a href="#任务队列和Event-loop" class="headerlink" title="任务队列和Event-loop"></a>任务队列和Event-loop</h1><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<h2 id="JS-调用栈"><a href="#JS-调用栈" class="headerlink" title="JS 调用栈"></a>JS 调用栈</h2><p>JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空</p>
<h2 id="同步任务、异步任务"><a href="#同步任务、异步任务" class="headerlink" title="同步任务、异步任务"></a>同步任务、异步任务</h2><p>JavaScript单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环ss</p>
<h2 id="异步任务触发"><a href="#异步任务触发" class="headerlink" title="异步任务触发"></a>异步任务触发</h2><p>setTimeout和setInterval<br>DOM事件<br>ES6中的Promiss</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>渲染机制</tag>
        <tag>同步任务</tag>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>页面性能</title>
    <url>/2020/04/16/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>资源合并，减少http请求<br>非核心代码一步加载 -&gt; 异步加载的方式 -&gt; 异步加载的区别<br>利用浏览器缓存 -&gt; 缓存的分类  -&gt;  缓存的原理<br>使用CDN<br>与解析DNS</p>
<a id="more"></a>

<h1 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h1><h2 id="提升页面性能的方法"><a href="#提升页面性能的方法" class="headerlink" title="提升页面性能的方法"></a>提升页面性能的方法</h2><ol>
<li>资源合并，减少http请求</li>
<li>非核心代码一步加载 -&gt; 异步加载的方式 -&gt; 异步加载的区别</li>
<li>利用浏览器缓存 -&gt; 缓存的分类  -&gt;  缓存的原理</li>
<li>使用CDN</li>
<li>与解析DNS <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;host_name_to_prefetchs.com&quot;&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><ol>
<li>异步加载的方式<ol>
<li>动态脚本加载</li>
<li>defer</li>
<li>async</li>
</ol>
</li>
<li>异步加载的区别<ol>
<li>defer是在html解析完后才会执行，如果是多个，按照加载的顺序依次执行</li>
<li>async是在加载完后立即执行，如果是多个，执行顺序与加载顺序无关</li>
</ol>
</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol>
<li>缓存的分类<ol>
<li>强缓存<ol>
<li>Expires过期时间-绝对时间/Cache-Control过期时间-相对时间</li>
</ol>
</li>
<li>协商缓存<ol>
<li>Last-Modified开始时间/If-Modified-Since结束时间</li>
<li>Etag对比hash值/If-None-Match过期强缓存时间</li>
</ol>
</li>
</ol>
</li>
<li>缓存的原理<br> 当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>渲染机制</tag>
        <tag>同步任务</tag>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染机制</title>
    <url>/2020/04/16/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>HTML经过html Parser转成DOM tree，Style Sheets经过 CSS Parser转成 Style Rules，然后经过整合形成一个Render Tree，需要渲染的结构。Render Tree通过Layout知道元素的位置，然后Painting 绘制出来界面。</p>
<a id="more"></a>

<h1 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h1><h2 id="渲染机制类"><a href="#渲染机制类" class="headerlink" title="渲染机制类"></a>渲染机制类</h2><h3 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h3><p>DTD（document type definition，文档类型定义）就是告诉浏览器是什么文档类型，浏览器根据这些来决定用什么类型来解析文件</p>
<p>DOCTYPE就是用来说明文件类型和DTD规范及验证文件合法性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># HTML5</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line"># HTML 4.01 Strict 严格模式 不可以使用弃用元素</span><br><span class="line"></span><br><span class="line"># HTML 4.01 Transitional 宽松模式 可以使用弃用元素</span><br></pre></td></tr></table></figure>
<h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p><img src="/assets/xuanran/2020-04-16_20-58-46.png" alt=""></p>
<p>HTML经过html Parser转成DOM tree，Style Sheets经过 CSS Parser转成 Style Rules，然后经过整合形成一个Render Tree，需要渲染的结构。Render Tree通过Layout知道元素的位置，然后Painting 绘制出来界面。</p>
<h3 id="重排Reflow"><a href="#重排Reflow" class="headerlink" title="重排Reflow"></a>重排Reflow</h3><p>DOM结构中各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式计算并根据计算结果将元素出现在该出现的地方，这个过程就是reflow</p>
<h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">增加，删除、修改DOM会导致Reflow或Repaint</span><br><span class="line">移动位置，动画</span><br><span class="line">修改样式</span><br><span class="line">Resize窗口（移动端不会），滚动</span><br><span class="line">修改默认字体</span><br></pre></td></tr></table></figure>

<p>触发动画的开始不要用diaplay:none属性值，因为它会引起Layout、Paint环节，通过切换类名就已经是一种很好的办法。<br>还有就是，translate属性值来替换top/left/right/bottom的切换，scale属性值替换width/height，opacity属性替换display/visibility等</p>
<h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p>当各种盒子的位置、大小及其他属性都确定下来后，浏览器就会把这些元素根据各自的特性绘制一遍，于是页面的内容出现了，这个过程就是Repaint</p>
<h4 id="触发-1"><a href="#触发-1" class="headerlink" title="触发"></a>触发</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOM改动</span><br><span class="line">CSS改动</span><br></pre></td></tr></table></figure>

<p>减少操作，或统一操作可以减少重绘Repaint</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>渲染机制</tag>
        <tag>重排</tag>
        <tag>重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>单线程与异步</title>
    <url>/2020/03/30/%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>js作为单线程语言,对异步是需要的。</p>
<a id="more"></a>

<h1 id="单线程和异步"><a href="#单线程和异步" class="headerlink" title="单线程和异步"></a>单线程和异步</h1><pre><code>1. 单线程-只有一个线程，只能做一件事情
2. 原因-避免DOM渲染的冲突
    1. 浏览器需要渲染DOM
    2. js可以修改DOM结构
    3. js执行的时候，浏览器DOM渲染会暂停
    4. 两段js不能同时执行（都修改DOM就会冲突）
    5. webworker支持多线程，但是不能访问DOM（h5）
3. 解决方案-异步
    1. 没按照书写方式执行，可读性差
    2. callback中不容易模块化</code></pre><h1 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h1><pre><code>* 事件轮训、事件循环,js实现异步的具体解决方案
* 同步代码，直接执行
* 异步函数先放在异步队列中
* 待同步函数执行完毕，轮训执行异步队列的函数</code></pre><h1 id="js解决异步的方案"><a href="#js解决异步的方案" class="headerlink" title="js解决异步的方案"></a>js解决异步的方案</h1><h2 id="Deferred"><a href="#Deferred" class="headerlink" title="$.Deferred()"></a>$.Deferred()</h2><pre><code>* 无法改变js异步和单线程的本质
* 只能从写法上杜绝callback的形式
* 他是一种语法糖，但是解藕代码
* 很好的体现：开放封闭原则(对拓展开发对修改封闭)

如果返回的是一个Deferred，可以在结果态出现后，依旧可以修改结果。
所以最好的场景则是返回一个Promise。

Deferred的api可以分成两类
第一类 Deferred.resolve() Deferred.reject() //操作型
第二类 Deferred.then Deferred.done Deferred.fail //结果型 监听</code></pre><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h2 id="async-await的使用"><a href="#async-await的使用" class="headerlink" title="async/await的使用"></a>async/await的使用</h2><pre><code>async/await是一种同步写法
使用await函数必须使用async标示
await必须跟promise实例
需要babel-polyfill(兼容)</code></pre>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>Deferred</tag>
        <tag>异步</tag>
        <tag>async/await</tag>
        <tag>callback hell</tag>
      </tags>
  </entry>
  <entry>
    <title>Class与js构造函数的区别</title>
    <url>/2020/03/30/Class%E4%B8%8Ejs%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Class本质上是语法糖，使用的prototype</p>
<a id="more"></a>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>class在语法上更加贴合面向对象的写法</li>
<li>class实现继承更加易读、易理解</li>
<li>适合面向对象的编程习惯人员</li>
<li>本质上是语法糖，使用的prototype</li>
</ol>
<h1 id="Js构造函数"><a href="#Js构造函数" class="headerlink" title="Js构造函数"></a>Js构造函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MathHandle</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x= x;</span><br><span class="line">    <span class="keyword">this</span>.y= y;</span><br><span class="line">&#125;</span><br><span class="line">MathHandle.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x+ <span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MathHandle(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>

<h1 id="CLass基本语法"><a href="#CLass基本语法" class="headerlink" title="CLass基本语法"></a>CLass基本语法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x</span><br><span class="line">        <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    add()&#123;</span><br><span class="line">        conssole.log(<span class="keyword">this</span>.x+<span class="keyword">this</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MathHandle(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> MathHandle <span class="comment">// function </span></span><br><span class="line"><span class="comment">// 在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性（__proto__）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型</span></span><br><span class="line"><span class="comment">// prototype  显式原型 </span></span><br><span class="line"><span class="comment">// __proto__  隐形原型</span></span><br><span class="line">MathHandle === MathHandle.prototype.constructor <span class="comment">// true</span></span><br><span class="line">m.__proto__ == MathHandle.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eat= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.say= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">var</span> hashiqi = <span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">//Class继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name) <span class="comment">//执行父类的constructor</span></span><br><span class="line">        <span class="keyword">this</span>.name= name</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hashiqi = <span class="keyword">new</span> D(<span class="string">'name'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/assets/class/15853171871187.jpg" alt=""><br>在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性（<strong>proto</strong>）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型。<br>方法(Function)是一个特殊的对象，除了和其他对象一样具有<strong>proto</strong>属性以外，它还有一个自己特有的原型属性(prototype)，这个属性是一个指针，指向原型对象。原型对象也有一个属性叫constructor，这个属性包含一个指针，指向原构造函数。<br>注意：通过Function.prototype.bind方法构造出来的函数没有prototype属性。<br>注意：Object.prototype.这个对象的是个例外，它的<strong>proto</strong>值为null。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2020/03/30/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<blockquote>
<p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p>
</blockquote>
</blockquote>
<a id="more"></a>

<h1 id="模块化的定义"><a href="#模块化的定义" class="headerlink" title="模块化的定义"></a>模块化的定义</h1><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p>
<h2 id="一个模块的组成"><a href="#一个模块的组成" class="headerlink" title="一个模块的组成"></a>一个模块的组成</h2><ul>
<li>数据-&gt;内部的属性</li>
<li>操作数据的行为-&gt;内部的函数</li>
</ul>
<h1 id="模块化的标准"><a href="#模块化的标准" class="headerlink" title="模块化的标准"></a>模块化的标准</h1><ol>
<li>CommonJS</li>
<li>AMD</li>
<li>Es6</li>
</ol>
<h1 id="各个版本模块化的使用"><a href="#各个版本模块化的使用" class="headerlink" title="各个版本模块化的使用"></a>各个版本模块化的使用</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>定义暴露模块 : exports</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.xxx = value</span><br><span class="line"><span class="built_in">module</span>.exports = value</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入模块 : require</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'模块名/模块相对路径'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>定义暴露模块: define([依赖模块名], function(){return 模块对象})</p>
</li>
<li><p>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="comment">//基本路径</span></span><br><span class="line">  baseUrl : <span class="string">'js/'</span>,</span><br><span class="line">  <span class="comment">//标识名称与路径的映射</span></span><br><span class="line">  paths : &#123;</span><br><span class="line">    <span class="string">'模块1'</span> : <span class="string">'modules/模块1'</span>,</span><br><span class="line">    <span class="string">'模块2'</span> : <span class="string">'modules/模块2'</span>,</span><br><span class="line">    <span class="string">'angular'</span> : <span class="string">'libs/angular'</span>,</span><br><span class="line">    <span class="string">'angular-messages'</span> : <span class="string">'libs/angular-messages'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//非AMD的模块</span></span><br><span class="line">  shim : &#123;</span><br><span class="line">    <span class="string">'angular'</span> : &#123;</span><br><span class="line">        exports : <span class="string">'angular'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'angular-messages'</span> : &#123;</span><br><span class="line">        exports : <span class="string">'angular-messages'</span>,</span><br><span class="line">        deps : [<span class="string">'angular'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Es6"><a href="#Es6" class="headerlink" title="Es6"></a>Es6</h2><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>分别暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>统一暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;fun,fun2&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt;&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">improt xxx <span class="keyword">from</span> <span class="string">'./...'</span></span><br><span class="line">xxx()</span><br></pre></td></tr></table></figure>

<h1 id="模块化进化"><a href="#模块化进化" class="headerlink" title="模块化进化"></a>模块化进化</h1><ol>
<li>全局function模式</li>
</ol>
<ul>
<li><p>编码: 全局变量/函数</p>
</li>
<li><p>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>namespace模式</li>
</ol>
<ul>
<li><p>编码: 将数据/行为封装到对象中</p>
</li>
<li><p>解决: 命名冲突(减少了全局变量)</p>
</li>
<li><p>问题: 数据不安全(外部可以直接修改模块内部的数据)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = &#123;</span><br><span class="line">	a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>IIFE模式/增强(匿名闭包)</li>
</ol>
<ul>
<li><p>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</p>
</li>
<li><p>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</p>
</li>
<li><p>引入依赖: 通过函数形参来引入依赖模块</p>
</li>
</ul>
<p>// (function(window, module2){<br>//     var data = ‘atguigu.com’<br>//     function foo() {<br>// 　　        module2.xxx()<br>// 　　     console.log(‘foo()’+data)<br>// 　　 }<br>// 　　 function bar() {<br>//  　　      console.log(‘bar()’+data)<br>// 　　 }<br>// 　　 window.module = {foo}<br>// })(window, module2)</p>
<h1 id="Es6模块化的使用和编译环境"><a href="#Es6模块化的使用和编译环境" class="headerlink" title="Es6模块化的使用和编译环境"></a>Es6模块化的使用和编译环境</h1><ul>
<li>语法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// util1</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> ./util.js</span><br><span class="line"><span class="comment">// 多个</span></span><br><span class="line"><span class="keyword">import</span> &#123;fn1,fn2&#125; <span class="keyword">from</span> ./util.js</span><br></pre></td></tr></table></figure>

<ul>
<li>工具</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel</span></span><br><span class="line">babel-core </span><br><span class="line">babel-preset-es2015 </span><br><span class="line">babel-preset-latest</span><br><span class="line"><span class="comment">// webpack</span></span><br><span class="line">webpack</span><br><span class="line">babel-loaders</span><br><span class="line"><span class="comment">// rollup.js</span></span><br><span class="line"><span class="comment">// 压缩的更小 small pieces</span></span><br><span class="line">rollup</span><br><span class="line">rollup-plugin-node-resolve</span><br><span class="line">rollup-plugin-babel</span><br><span class="line">babel-plugin-external-helpers</span><br><span class="line">babel-preset-latest</span><br></pre></td></tr></table></figure>

<p>rollup功能单一，webpack功能强大</p>
<ul>
<li>配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.config.js</span><br><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;es2015&quot;,&quot;latest&quot;],</span><br><span class="line">    &quot;plugins&quot;:[]</span><br><span class="line">&#125;s</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    entry:&quot;.&#x2F;src&#x2F;index.js&quot;, &#x2F;&#x2F;入口</span><br><span class="line">    output:&#123; &#x2F;&#x2F;出口</span><br><span class="line">        path:__dirname, &#x2F;&#x2F;地址</span><br><span class="line">        filename:&quot;.&#x2F;build&#x2F;bundle.js&quot; &#x2F;&#x2F;文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123; &#x2F;&#x2F;模块</span><br><span class="line">        rules:[ &#x2F;&#x2F;规则</span><br><span class="line">            &#123;</span><br><span class="line">            test:&#x2F;\.js?$&#x2F;, &#x2F;&#x2F;使用规则的文件类型</span><br><span class="line">            exclude:&#39;&#x2F;(node_modules)&#x2F;&#39;, &#x2F;&#x2F;排除</span><br><span class="line">            loader:&#39;babel-loader&#39; &#x2F;&#x2F;使用的规则文件</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rollup</span><br><span class="line">&#x2F;&#x2F; 配置编译环境</span><br><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[</span><br><span class="line">        [&quot;latest&quot;:&#123;</span><br><span class="line">            &quot;es2015&quot;:&#123;</span><br><span class="line">                &quot;modules&quot;:false &#x2F;&#x2F;过滤modules</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;:[&quot;external-helpers&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rollup.config.js</span><br><span class="line">import babel from &#39;rollup-plugin-babel&#39;</span><br><span class="line">import resolve from &#39;rollup&#x3D;plugin-node-resolve&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    entry:&#39;src&#x2F;index.js&#39;, &#x2F;&#x2F;入口</span><br><span class="line">    format:&#39;umd&#39;,   &#x2F;&#x2F;引用格式(兼容方式)</span><br><span class="line">    plugins:[   &#x2F;&#x2F;插件</span><br><span class="line">        resolve(),</span><br><span class="line">        babel(&#123;</span><br><span class="line">            exclude:&quot;node_modules&#x2F;**&quot; &#x2F;&#x2F;过滤</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    dest:&#39;build&#x2F;bundle.js&#39;  &#x2F;&#x2F;出口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>通过抓包工具实现线上调试</title>
    <url>/2020/03/26/%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>工具的诞生就是用来解决问题的！当然有时候工具出现的目的并不是单纯为了解决这个问题。但是，他附带的价值却是能解决它。</p>
<a id="more"></a>
<p>这是值得思考的，这也是一个开发者必须要去思考的地方。</p>
<p>团队的小伙子一直抱怨。在测试或者交付之后的代码样式，需要开启后端IDE去编辑。</p>
<p>很多初入行的、或者在小团队的前端开发都有过这样的经历。在前后端没有分离的项目中，都是先交付静态界面，然后制成jsp后就需要使用后端的IDE，顺便配置好后端环境才能去调试和修改。</p>
<p>这无疑是痛苦的，成效低且没有任何成就感。而且在学习配置后端环境这种没有意义的学习成本是没有价值的。</p>
<p>需要去思考，这种思考并不是推翻开发模式。这无疑不现实，所以我们只能思考如何如何减负。</p>
<p>在上面所说的前提环境中，哪些是必须的。我们需要整理出来。</p>
<p>当然，修复还是前端去修复。总不能不管，也不能说要后端写业务的去修改样式。</p>
<p>所以，中间的过程中我们应该是可以去除一些过程。</p>
<p>比如，可不可以不用后端的IDE和环境，能不能用线上、运行的或者可访问的地址来做调试，跳过这些复杂和成本高昂的过程。</p>
<p>当然可以，这个时候Charles出现在视野了。让我们跳过熟悉和不停开启后端IDE的过程，回到前端熟悉领域和场地。</p>
<p>首先先明确名词:</p>
<blockquote>
<blockquote>
<p>抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。</p>
</blockquote>
</blockquote>
<p>将运行着的环境资源替换成本地编辑的资源，这就是调试的核心。Charles选择需要替换的资源，选择Map Local，将线上资源替换成本地资源（编译后的资源）。</p>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>从新开始</title>
    <url>/2020/03/17/%E4%BB%8E%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>试着去记录一些东西，把散碎的支离破碎整理起来。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
