<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>单线程与异步</title>
    <url>/2020/03/30/%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>我们并不能否认js作为单线程语言的本质上对异步的需要。</p>
<a id="more"></a>

<h1 id="单线程和异步"><a href="#单线程和异步" class="headerlink" title="单线程和异步"></a>单线程和异步</h1><pre><code>1. 单线程-只有一个线程，只能做一件事情
2. 原因-避免DOM渲染的冲突
    1. 浏览器需要渲染DOM
    2. js可以修改DOM结构
    3. js执行的时候，浏览器DOM渲染会暂停
    4. 两段js不能同时执行（都修改DOM就会冲突）
    5. webworker支持多线程，但是不能访问DOM（h5）
3. 解决方案-异步
    1. 没按照书写方式执行，可读性差
    2. callback中不容易模块化</code></pre><h1 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h1><pre><code>* 事件轮训、事件循环,js实现异步的具体解决方案
* 同步代码，直接执行
* 异步函数先放在异步队列中
* 待同步函数执行完毕，轮训执行异步队列的函数</code></pre><h1 id="js解决异步的方案"><a href="#js解决异步的方案" class="headerlink" title="js解决异步的方案"></a>js解决异步的方案</h1><h2 id="Deferred"><a href="#Deferred" class="headerlink" title="$.Deferred()"></a>$.Deferred()</h2><pre><code>* 无法改变js异步和单线程的本质
* 只能从写法上杜绝callback的形式
* 他是一种语法糖，但是解藕代码
* 很好的体现：开放封闭原则(对拓展开发对修改封闭)

如果返回的是一个Deferred，可以在结果态出现后，依旧可以修改结果。
所以最好的场景则是返回一个Promise。

Deferred的api可以分成两类
第一类 Deferred.resolve() Deferred.reject() //操作型
第二类 Deferred.then Deferred.done Deferred.fail //结果型 监听</code></pre><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h2 id="async-await的使用"><a href="#async-await的使用" class="headerlink" title="async/await的使用"></a>async/await的使用</h2><pre><code>async/await是一种同步写法
使用await函数必须使用async标示
await必须跟promise实例
需要babel-polyfill(兼容)</code></pre>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>Deferred</tag>
        <tag>异步</tag>
        <tag>async/await</tag>
        <tag>callback hell</tag>
      </tags>
  </entry>
  <entry>
    <title>Class与js构造函数的区别</title>
    <url>/2020/03/30/Class%E4%B8%8Ejs%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>Class本质上是语法糖，使用的prototype</p>
<a id="more"></a>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>class在语法上更加贴合面向对象的写法</li>
<li>class实现继承更加易读、易理解</li>
<li>适合面向对象的编程习惯人员</li>
<li>本质上是语法糖，使用的prototype</li>
</ol>
<h1 id="Js构造函数"><a href="#Js构造函数" class="headerlink" title="Js构造函数"></a>Js构造函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MathHandle</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x= x;</span><br><span class="line">    <span class="keyword">this</span>.y= y;</span><br><span class="line">&#125;</span><br><span class="line">MathHandle.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x+ <span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MathHandle(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>

<h1 id="CLass基本语法"><a href="#CLass基本语法" class="headerlink" title="CLass基本语法"></a>CLass基本语法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x</span><br><span class="line">        <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    add()&#123;</span><br><span class="line">        conssole.log(<span class="keyword">this</span>.x+<span class="keyword">this</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MathHandle(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> MathHandle <span class="comment">// function </span></span><br><span class="line"><span class="comment">// 在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性（__proto__）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型</span></span><br><span class="line"><span class="comment">// prototype  显式原型 </span></span><br><span class="line"><span class="comment">// __proto__  隐形原型</span></span><br><span class="line">MathHandle === MathHandle.prototype.constructor <span class="comment">// true</span></span><br><span class="line">m.__proto__ == MathHandle.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eat= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.say= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">var</span> hashiqi = <span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">//Class继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name) <span class="comment">//执行父类的constructor</span></span><br><span class="line">        <span class="keyword">this</span>.name= name</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hashiqi = <span class="keyword">new</span> D(<span class="string">'name'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/assets/class/15853171871187.jpg" alt=""><br>在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性（<strong>proto</strong>）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型。<br>方法(Function)是一个特殊的对象，除了和其他对象一样具有<strong>proto</strong>属性以外，它还有一个自己特有的原型属性(prototype)，这个属性是一个指针，指向原型对象。原型对象也有一个属性叫constructor，这个属性包含一个指针，指向原构造函数。<br>注意：通过Function.prototype.bind方法构造出来的函数没有prototype属性。<br>注意：Object.prototype.这个对象的是个例外，它的<strong>proto</strong>值为null。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2020/03/30/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<blockquote>
<p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p>
</blockquote>
</blockquote>
<a id="more"></a>

<h1 id="模块化的定义"><a href="#模块化的定义" class="headerlink" title="模块化的定义"></a>模块化的定义</h1><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p>
<h2 id="一个模块的组成"><a href="#一个模块的组成" class="headerlink" title="一个模块的组成"></a>一个模块的组成</h2><ul>
<li>数据-&gt;内部的属性</li>
<li>操作数据的行为-&gt;内部的函数</li>
</ul>
<h1 id="模块化的标准"><a href="#模块化的标准" class="headerlink" title="模块化的标准"></a>模块化的标准</h1><ol>
<li>CommonJS</li>
<li>AMD</li>
<li>Es6</li>
</ol>
<h1 id="各个版本模块化的使用"><a href="#各个版本模块化的使用" class="headerlink" title="各个版本模块化的使用"></a>各个版本模块化的使用</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>定义暴露模块 : exports</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.xxx = value</span><br><span class="line"><span class="built_in">module</span>.exports = value</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入模块 : require</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'模块名/模块相对路径'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>定义暴露模块: define([依赖模块名], function(){return 模块对象})</p>
</li>
<li><p>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="comment">//基本路径</span></span><br><span class="line">  baseUrl : <span class="string">'js/'</span>,</span><br><span class="line">  <span class="comment">//标识名称与路径的映射</span></span><br><span class="line">  paths : &#123;</span><br><span class="line">    <span class="string">'模块1'</span> : <span class="string">'modules/模块1'</span>,</span><br><span class="line">    <span class="string">'模块2'</span> : <span class="string">'modules/模块2'</span>,</span><br><span class="line">    <span class="string">'angular'</span> : <span class="string">'libs/angular'</span>,</span><br><span class="line">    <span class="string">'angular-messages'</span> : <span class="string">'libs/angular-messages'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//非AMD的模块</span></span><br><span class="line">  shim : &#123;</span><br><span class="line">    <span class="string">'angular'</span> : &#123;</span><br><span class="line">        exports : <span class="string">'angular'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'angular-messages'</span> : &#123;</span><br><span class="line">        exports : <span class="string">'angular-messages'</span>,</span><br><span class="line">        deps : [<span class="string">'angular'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Es6"><a href="#Es6" class="headerlink" title="Es6"></a>Es6</h2><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>分别暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>统一暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;fun,fun2&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt;&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">improt xxx <span class="keyword">from</span> <span class="string">'./...'</span></span><br><span class="line">xxx()</span><br></pre></td></tr></table></figure>

<h1 id="模块化进化"><a href="#模块化进化" class="headerlink" title="模块化进化"></a>模块化进化</h1><ol>
<li>全局function模式</li>
</ol>
<ul>
<li><p>编码: 全局变量/函数</p>
</li>
<li><p>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>namespace模式</li>
</ol>
<ul>
<li><p>编码: 将数据/行为封装到对象中</p>
</li>
<li><p>解决: 命名冲突(减少了全局变量)</p>
</li>
<li><p>问题: 数据不安全(外部可以直接修改模块内部的数据)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = &#123;</span><br><span class="line">	a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>IIFE模式/增强(匿名闭包)</li>
</ol>
<ul>
<li><p>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</p>
</li>
<li><p>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</p>
</li>
<li><p>引入依赖: 通过函数形参来引入依赖模块</p>
</li>
</ul>
<p>// (function(window, module2){<br>//     var data = ‘atguigu.com’<br>//     function foo() {<br>// 　　        module2.xxx()<br>// 　　     console.log(‘foo()’+data)<br>// 　　 }<br>// 　　 function bar() {<br>//  　　      console.log(‘bar()’+data)<br>// 　　 }<br>// 　　 window.module = {foo}<br>// })(window, module2)</p>
<h1 id="Es6模块化的使用和编译环境"><a href="#Es6模块化的使用和编译环境" class="headerlink" title="Es6模块化的使用和编译环境"></a>Es6模块化的使用和编译环境</h1><ul>
<li>语法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// util1</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> ./util.js</span><br><span class="line"><span class="comment">// 多个</span></span><br><span class="line"><span class="keyword">import</span> &#123;fn1,fn2&#125; <span class="keyword">from</span> ./util.js</span><br></pre></td></tr></table></figure>

<ul>
<li>工具</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel</span></span><br><span class="line">babel-core </span><br><span class="line">babel-preset-es2015 </span><br><span class="line">babel-preset-latest</span><br><span class="line"><span class="comment">// webpack</span></span><br><span class="line">webpack</span><br><span class="line">babel-loaders</span><br><span class="line"><span class="comment">// rollup.js</span></span><br><span class="line"><span class="comment">// 压缩的更小 small pieces</span></span><br><span class="line">rollup</span><br><span class="line">rollup-plugin-node-resolve</span><br><span class="line">rollup-plugin-babel</span><br><span class="line">babel-plugin-external-helpers</span><br><span class="line">babel-preset-latest</span><br></pre></td></tr></table></figure>

<p>rollup功能单一，webpack功能强大</p>
<ul>
<li>配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.config.js</span><br><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;es2015&quot;,&quot;latest&quot;],</span><br><span class="line">    &quot;plugins&quot;:[]</span><br><span class="line">&#125;s</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    entry:&quot;.&#x2F;src&#x2F;index.js&quot;, &#x2F;&#x2F;入口</span><br><span class="line">    output:&#123; &#x2F;&#x2F;出口</span><br><span class="line">        path:__dirname, &#x2F;&#x2F;地址</span><br><span class="line">        filename:&quot;.&#x2F;build&#x2F;bundle.js&quot; &#x2F;&#x2F;文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123; &#x2F;&#x2F;模块</span><br><span class="line">        rules:[ &#x2F;&#x2F;规则</span><br><span class="line">            &#123;</span><br><span class="line">            test:&#x2F;\.js?$&#x2F;, &#x2F;&#x2F;使用规则的文件类型</span><br><span class="line">            exclude:&#39;&#x2F;(node_modules)&#x2F;&#39;, &#x2F;&#x2F;排除</span><br><span class="line">            loader:&#39;babel-loader&#39; &#x2F;&#x2F;使用的规则文件</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rollup</span><br><span class="line">&#x2F;&#x2F; 配置编译环境</span><br><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[</span><br><span class="line">        [&quot;latest&quot;:&#123;</span><br><span class="line">            &quot;es2015&quot;:&#123;</span><br><span class="line">                &quot;modules&quot;:false &#x2F;&#x2F;过滤modules</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;:[&quot;external-helpers&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rollup.config.js</span><br><span class="line">import babel from &#39;rollup-plugin-babel&#39;</span><br><span class="line">import resolve from &#39;rollup&#x3D;plugin-node-resolve&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    entry:&#39;src&#x2F;index.js&#39;, &#x2F;&#x2F;入口</span><br><span class="line">    format:&#39;umd&#39;,   &#x2F;&#x2F;引用格式(兼容方式)</span><br><span class="line">    plugins:[   &#x2F;&#x2F;插件</span><br><span class="line">        resolve(),</span><br><span class="line">        babel(&#123;</span><br><span class="line">            exclude:&quot;node_modules&#x2F;**&quot; &#x2F;&#x2F;过滤</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    dest:&#39;build&#x2F;bundle.js&#39;  &#x2F;&#x2F;出口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>通过抓包工具实现线上调试</title>
    <url>/2020/03/26/%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>工具的诞生就是用来解决问题的！当然有时候工具出现的目的并不是单纯为了解决这个问题。但是，他附带的价值却是能解决它。</p>
<a id="more"></a>
<p>这是值得思考的，这也是一个开发者必须要去思考的地方。</p>
<p>团队的小伙子一直抱怨。在测试或者交付之后的代码样式，需要开启后端IDE去编辑。</p>
<p>很多初入行的、或者在小团队的前端开发都有过这样的经历。在前后端没有分离的项目中，都是先交付静态界面，然后制成jsp后就需要使用后端的IDE，顺便配置好后端环境才能去调试和修改。</p>
<p>这无疑是痛苦的，成效低且没有任何成就感。而且在学习配置后端环境这种没有意义的学习成本是没有价值的。</p>
<p>需要去思考，这种思考并不是推翻开发模式。这无疑不现实，所以我们只能思考如何如何减负。</p>
<p>在上面所说的前提环境中，哪些是必须的。我们需要整理出来。</p>
<p>当然，修复还是前端去修复。总不能不管，也不能说要后端写业务的去修改样式。</p>
<p>所以，中间的过程中我们应该是可以去除一些过程。</p>
<p>比如，可不可以不用后端的IDE和环境，能不能用线上、运行的或者可访问的地址来做调试，跳过这些复杂和成本高昂的过程。</p>
<p>当然可以，这个时候Charles出现在视野了。让我们跳过熟悉和不停开启后端IDE的过程，回到前端熟悉领域和场地。</p>
<p>首先先明确名词:</p>
<blockquote>
<blockquote>
<p>抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。</p>
</blockquote>
</blockquote>
<p>将运行着的环境资源替换成本地编辑的资源，这就是调试的核心。Charles选择需要替换的资源，选择Map Local，将线上资源替换成本地资源（编译后的资源）。</p>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>从新开始</title>
    <url>/2020/03/17/%E4%BB%8E%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>试着去记录一些东西，把散碎的支离破碎整理起来。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
