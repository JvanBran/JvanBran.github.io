<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>typescript</title>
    <url>/2020/04/28/typescript/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>TypeScript是javascipt的超集更是约束，是对弱类型语言的加强。</p>

          </blockquote>

<a id="more"></a>

<h1 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在使用Typescript时必须指定数据类型，这样才能对数据进行校验</p>
<h3 id="Boolean、String、Number"><a href="#Boolean、String、Number" class="headerlink" title="Boolean、String、Number"></a>Boolean、String、Number</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Boolean</span></span><br><span class="line"><span class="keyword">var</span> booleanSt:<span class="built_in">Boolean</span></span><br><span class="line">booleanSt = <span class="literal">false</span></span><br><span class="line"><span class="comment">//Number</span></span><br><span class="line"><span class="keyword">var</span> numberSt:<span class="built_in">number</span></span><br><span class="line">numberSt = <span class="number">11</span></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">var</span> stringSt:<span class="built_in">String</span></span><br><span class="line">stringSt = <span class="string">'2222'</span></span><br></pre></td></tr></table></figure>

<h3 id="Array、tuple"><a href="#Array、tuple" class="headerlink" title="Array、tuple"></a>Array、tuple</h3><p>tuple元组类型是对Array类型的补充，可以在数组中自定义不同下标下的各种类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arraySt:<span class="built_in">string</span>[]</span><br><span class="line"><span class="keyword">var</span> arrayNu:<span class="built_in">number</span>[]</span><br><span class="line"><span class="keyword">var</span> arrayBo:<span class="built_in">Boolean</span>[]</span><br><span class="line">arraySt = [<span class="string">'1'</span>]</span><br><span class="line">arrayNu = [<span class="number">1</span>]</span><br><span class="line">arrayBo = [<span class="literal">false</span>]</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">var</span> arraySt1:<span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">var</span> arrayNu1:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;</span><br><span class="line"><span class="keyword">var</span> arrayBo1:<span class="built_in">Array</span>&lt;<span class="built_in">Boolean</span>&gt;</span><br><span class="line">arraySt1 = [<span class="string">'1'</span>]</span><br><span class="line">arrayNu1 = [<span class="number">1</span>]</span><br><span class="line">arrayBo1 = [<span class="literal">false</span>]</span><br><span class="line"><span class="comment">//tuple元组类型,每个位置指定类型</span></span><br><span class="line"><span class="keyword">var</span> tupleSr:[<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">tupleSr = [<span class="string">'111'</span>,<span class="number">22</span>]</span><br></pre></td></tr></table></figure>

<h3 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h3><p>枚举类型使用场景能是在某些需要约定的字典中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Flag &#123;success=<span class="number">1</span>,error=<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> ret:Flag = Flag.success</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color &#123;blue=<span class="string">'1122'</span>,red=<span class="string">'3344'</span>,orange=<span class="string">'5566'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> C:Color = Color.red <span class="comment">//没有值则显示下标</span></span><br></pre></td></tr></table></figure>

<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>any类型在数据驱动的项目或者架构时用的很少。一般是用来操作一些dom集合，因为使用any即是失去了对他的校验。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anySr:<span class="built_in">any</span></span><br><span class="line">anySr = <span class="string">'11'</span></span><br><span class="line">anySr = <span class="number">1</span></span><br><span class="line">anySr = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oBox:<span class="built_in">any</span> = <span class="built_in">document</span>.getElementById(<span class="string">'box'</span>)</span><br><span class="line">oBox.style.color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>如果方法需要返回指定类型的值是可以根据需要选择使用，如果连return不需要返回则是void类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run1</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run2</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run3</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">&#125;</span><br><span class="line">run1()</span><br><span class="line">run2()</span><br><span class="line">run3()</span><br></pre></td></tr></table></figure>

<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never其他类型（包括null和undefined）的自类型，代表从不会出现的值。确实也很少用    ，比如我们用来包裹一个异常。</p>
<h3 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a>null、undefined</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> undefinedSt:<span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">var</span> nullSt:<span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>使用 ｜ 可以允许多个返回结果</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="传参数"><a href="#传参数" class="headerlink" title="传参数"></a>传参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run3</span>(<span class="params"></span>):<span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'run'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名函数</span></span><br><span class="line"><span class="keyword">var</span> run4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNane</span>(<span class="params">name:<span class="built_in">string</span>,age:<span class="built_in">Number</span></span>):<span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> --- <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNane1</span>(<span class="params">name:<span class="built_in">string</span>,age?:<span class="built_in">Number</span></span>):<span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> --- <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNane1</span>(<span class="params">name:<span class="built_in">string</span>,age?:<span class="built_in">Number</span></span>):<span class="title">String</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;name&#125;</span> --- <span class="subst">$&#123;age&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="剩余函数"><a href="#剩余函数" class="headerlink" title="剩余函数"></a>剩余函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNane3</span>(<span class="params">...result:<span class="built_in">number</span>[]</span>):<span class="title">Array</span>&lt;<span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>es5中会被覆盖</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">age:<span class="built_in">number</span></span>):<span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">str:<span class="built_in">any</span></span>):<span class="title">any</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> str === <span class="string">'string'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'姓名'</span>+str;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'年龄'</span>+str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">getName(<span class="string">'11'</span>)</span><br><span class="line">getName(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>在es5实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Jvan'</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">10</span>   <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//实例方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.getInfo =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链的属性会被共享，构造函数不会</span></span><br><span class="line">Person.prototype.sex = <span class="string">'男'</span>;</span><br><span class="line">Person.prototype.spaek=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'spaek'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person.getInfo()</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p.name: '</span>, p.name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p.sex: '</span>, p.sex);</span><br><span class="line">p.run()</span><br><span class="line">p.spaek()</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象冒充</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>); <span class="comment">//对象冒充实现继承构造函数的属性和方法，但是不能继承原型链的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web1</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">Web1.prototype = <span class="keyword">new</span> Person() <span class="comment">//原型链实现继承构造函数的属性和方法和继承原型链的方法 实例话后子类不能给父类传参数</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Web()</span><br><span class="line">o.run();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象冒充+原型链</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Web2</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Person.call(<span class="keyword">this</span>,name,age)</span><br><span class="line">&#125; </span><br><span class="line">Web2.prototype = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Web()</span><br><span class="line">o.run();</span><br></pre></td></tr></table></figure>

<p>在typescript</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person1&#123;</span><br><span class="line">    name:<span class="built_in">string</span>; <span class="comment">//属性 public</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">n:<span class="built_in">string</span></span>)&#123; <span class="comment">//构造函数,实例话触发</span></span><br><span class="line">        <span class="keyword">this</span>.name = n</span><br><span class="line">    &#125;</span><br><span class="line">    run():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    getName():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    setName(name:<span class="built_in">string</span>):<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> u= <span class="keyword">new</span> Person1(<span class="string">'Jvan'</span>)</span><br><span class="line">u.run()</span><br><span class="line">u.setName(<span class="string">'Jvan1'</span>)</span><br><span class="line">u.getName()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person2 <span class="keyword">extends</span> Person1&#123;</span><br><span class="line">    <span class="keyword">static</span> age:<span class="built_in">number</span> = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    speak():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    run():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'子类'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> print()&#123; <span class="comment">//静态方法 </span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'静态方法'</span>,Person2.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Person2(<span class="string">'Jvan2'</span>)</span><br><span class="line">y.run()</span><br><span class="line">y.setName(<span class="string">'Jvan1'</span>)</span><br><span class="line">y.getName()</span><br><span class="line">y.speak()</span><br></pre></td></tr></table></figure>

<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul>
<li>public 公有    只有在类、子类、类外可以访问</li>
<li>protected 保护 只有在类、子类可以访问</li>
<li>private 私有 只有在类可以访问</li>
<li>static 静态方法、属性 无法直接调用类里面的属性，如果要使用 要定义一个静态属性</li>
</ul>
<h3 id="abstract-抽象方法、抽象方法"><a href="#abstract-抽象方法、抽象方法" class="headerlink" title="abstract 抽象方法、抽象方法"></a>abstract 抽象方法、抽象方法</h3><p>只能放在抽象类，抽象类及方法用来 定义标准</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal&#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="keyword">abstract</span> eat():<span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//抽象子类必须实现抽象类里面的抽象方法</span></span><br><span class="line">    eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dog'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'cat'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>在面相对象的变成汇总，接口是一种规范定义，他定义了行为和动作的规范，在程序设计中，接口起到了一种规范和限制的作用。<br>接口定一个了某一批类中要遵循的规范，接口不关心这些类的内部状态数据，也不关心方法实现的细节，她只规定这批类里面必须提供某些方法，提供这些方法的类就可以满足实际需求。包括 属性、函数、可索引和类</p>
<h3 id="属性接口"><a href="#属性接口" class="headerlink" title="属性接口"></a>属性接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ajax Interface</span></span><br><span class="line"><span class="keyword">interface</span> ajaxConfig&#123;</span><br><span class="line">   <span class="keyword">type</span>:<span class="built_in">string</span>;</span><br><span class="line">   url:<span class="built_in">string</span>;</span><br><span class="line">   data?:<span class="built_in">string</span>;</span><br><span class="line">   datatype:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params">config:ajaxConfig</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">   xhr.open(config.type,config.url,<span class="literal">true</span>)</span><br><span class="line">   xhr.send(config.data)</span><br><span class="line">   xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span>&amp;&amp; xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'onreadystatechange'</span>);</span><br><span class="line">         <span class="keyword">if</span>(config.datatype == <span class="string">'json'</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Ajax(&#123;</span><br><span class="line">   <span class="keyword">type</span>:<span class="string">'GET'</span>,</span><br><span class="line">   url:<span class="string">'http://www.baidu.com'</span>,</span><br><span class="line">   data:<span class="string">'&#123;name:"11"&#125;'</span>,</span><br><span class="line">   datatype:<span class="string">'json'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h3><p>对方法传入的参数 以及返回值进行约束</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> encrypt&#123;</span><br><span class="line">   (key:<span class="built_in">string</span>,value:<span class="built_in">string</span>):<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> md5:encrypt = <span class="function"><span class="keyword">function</span>(<span class="params">key:<span class="built_in">string</span>,value:<span class="built_in">string</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> key+value</span><br><span class="line">&#125;</span><br><span class="line">md5(<span class="string">'11'</span>,<span class="string">'222'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可索引接口"><a href="#可索引接口" class="headerlink" title="可索引接口"></a>可索引接口</h3><p>对数组、对象的约束</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserArr&#123;</span><br><span class="line">   [index:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arrinterface:UserArr = [<span class="string">'22'</span>,<span class="string">'222'</span>]</span><br><span class="line"><span class="keyword">interface</span> UserObj&#123;</span><br><span class="line">   [index:<span class="built_in">string</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objinterface:UserObj = &#123;<span class="string">'name'</span>:<span class="string">'222'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h3><p>对类的约束和抽象类相似<br>关键字 implements</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animals&#123;</span><br><span class="line">    name1:<span class="built_in">string</span>;</span><br><span class="line">    eat1(str:<span class="built_in">string</span>):<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> asd <span class="keyword">implements</span> Animals&#123;</span><br><span class="line">	name:<span class="built_in">string</span>;</span><br><span class="line">  	<span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">   	&#125;</span><br><span class="line">   	eat():<span class="built_in">void</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'eat'</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="接口扩展"><a href="#接口扩展" class="headerlink" title="接口扩展"></a>接口扩展</h3><p>接口可以继承接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animalss&#123;</span><br><span class="line">   eat():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Persona <span class="keyword">extends</span> Animalss&#123;</span><br><span class="line">   word():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Conding&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Web5 <span class="keyword">extends</span> Conding <span class="keyword">implements</span> Persona&#123;</span><br><span class="line">   name:<span class="built_in">string</span>;</span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">      <span class="keyword">super</span>(name)</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line">   eat()&#123;&#125;</span><br><span class="line">   word()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>解决类接口方法的复用型，以及对不特定类型的支持并且添加校验（any就不校验类型）</p>
<h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;<span class="built_in">string</span>&gt;(<span class="string">'222'</span>)</span><br><span class="line">getData&lt;<span class="built_in">number</span>&gt;(<span class="number">222</span>)</span><br></pre></td></tr></table></figure>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MinClass&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> list:T[] = [];</span><br><span class="line">    add(num:T):<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.push(num)</span><br><span class="line">    &#125;</span><br><span class="line">    min():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> minNum = <span class="keyword">this</span>.list[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.list.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(minNum&gt;<span class="keyword">this</span>.list[i])&#123;</span><br><span class="line">                minNum = <span class="keyword">this</span>.list[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'minNum: '</span>, minNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MinClass&lt;<span class="built_in">number</span>&gt;() <span class="comment">//实例化类，并且执行了类的类型是number</span></span><br><span class="line">m.add(<span class="number">111</span>)</span><br><span class="line">m.add(<span class="number">11</span>)</span><br><span class="line">m.add(<span class="number">1</span>)</span><br><span class="line">m.min()</span><br><span class="line"><span class="keyword">var</span> m1 = <span class="keyword">new</span> MinClass&lt;<span class="built_in">string</span>&gt;() <span class="comment">//实例化类，并且执行了类的类型是string</span></span><br><span class="line">m1.add(<span class="string">'111'</span>)</span><br><span class="line">m1.add(<span class="string">'11'</span>)</span><br><span class="line">m1.add(<span class="string">'1'</span>)</span><br><span class="line">m1.min()</span><br></pre></td></tr></table></figure>

<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1s</span></span><br><span class="line"><span class="keyword">interface</span> ConfigFn&#123;</span><br><span class="line">    &lt;T&gt;(value1:T,value2:T):<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> setdata1:ConfigFn = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T,value1:T</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setData1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">setdata1&lt;<span class="built_in">string</span>&gt;(<span class="string">'12'</span>,<span class="string">'34'</span>)</span><br><span class="line">setdata1&lt;<span class="built_in">number</span>&gt;(<span class="number">12</span>,<span class="number">34</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">interface</span> ConfigFn1&lt;T&gt;&#123;</span><br><span class="line">    (value1:T,value2:T):<span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setData2</span>&lt;<span class="title">T</span>&gt;(<span class="params">value:T,value1:T</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setData2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> setData21:ConfigFn1&lt;<span class="built_in">string</span>&gt; = setData2</span><br><span class="line"><span class="keyword">var</span> setData22:ConfigFn1&lt;<span class="built_in">number</span>&gt; = setData2</span><br><span class="line">setData21(<span class="string">'11'</span>,<span class="string">'22'</span>)</span><br><span class="line">setData22(<span class="number">11</span>,<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Typescript</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>微信开发调试</title>
    <url>/2020/04/21/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>知其然，知其所以然。分析其中的原因，才能找到解决方案。</p>

          </blockquote>

<a id="more"></a>

<p>微信公众号开发中基于安全策略必须使用域名才能访问，其实第一次碰到这个问题，了解之后发现和浏览器同源策略的解决方案是类似的。</p>
<p>实际开发生产中，总是会不可避免的碰到，需要临时修改微信公众号修改内容的需求。</p>
<p>当然，也有几种通用解决方案。</p>
<p>使用natapp、使用ngrok之类的。</p>
<p>这些方案的起点都比较高，如果前端开发的能力有限就需要多端配合。</p>
<p>需要备案域名、服务器之类，时间和成本就会加剧。</p>
<p>如此，我们开始分析微信公众号本地调试中微信公众号做的一些安全策略。</p>
<p>首先，基于B/S的基本盘。我们基本可以判断，微信公众号的基本逻辑判断应该是，判断当前URL是否符合在服务器中备案的一致。</p>
<p>核心就出现了，浏览器地址栏中的url是否和服务器中的备案地址是否一致。</p>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>微信开发调试</tag>
      </tags>
  </entry>
  <entry>
    <title>作用域和闭包</title>
    <url>/2020/04/17/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>作用域保存自由变量，作用域链用来自由变量的查找。闭包对数据保护，不被访问。</p>

          </blockquote> 

<a id="more"></a>

<h1 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h1><ol>
<li>变量提升的理解<ol>
<li>变量定义</li>
<li>函数声明（表达式）</li>
</ol>
</li>
<li>this几种不同的使用场景<ol>
<li>作为构造函数执行</li>
<li>作为对象属性执行</li>
<li>作为普通函数执行</li>
<li>call apply bind</li>
</ol>
</li>
<li>创建10<a>标签，点击的时候弹出对应的序号</li>
<li>如何理解作用域<br> 自由变量<br> 作用域链，自由变量的查找<br> 闭包</li>
<li>实际开发中闭包的应用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFirstLoad</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> _list = []</span><br><span class="line">	<span class="keyword">return</span> funtion(id)&#123;</span><br><span class="line">		<span class="keyword">if</span>(_list.indexOf(id)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			_list.push(id)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> firstLoad = isFirstLoad()</span><br><span class="line">firstLoad(<span class="number">10</span>) <span class="comment">//true</span></span><br><span class="line">firstLoad(<span class="number">10</span>) <span class="comment">//false</span></span><br><span class="line">firstLoad(<span class="number">120</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>函数表达式vs函数声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>; <span class="comment">// var a; 声明</span></span><br><span class="line">fn(<span class="string">'zhangsan'</span>) <span class="comment">//zhangsan，20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>)</span>&#123; <span class="comment">// function fn; 声明</span></span><br><span class="line">	age = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(name,age) </span><br><span class="line">	<span class="keyword">var</span> age; <span class="comment">// var age 声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>范围：一段script或者函数</li>
<li>全局：变量定义、函数声明</li>
<li>函数：变量定义、函数声明、this、arguments</li>
</ol>
<p>js执行之前会将变量定义、函数声明、this、arguments取出来</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this要在执行时才能确认值，定义时无法确认</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	name : <span class="string">'A'</span>,</span><br><span class="line">	fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn() <span class="comment">// this === a  A</span></span><br><span class="line">a.fn.call(&#123;<span class="attr">name</span>:<span class="string">'B'</span>&#125;) <span class="comment">// this ===&#123;name:'B'&#125; B</span></span><br><span class="line"><span class="keyword">var</span> fn1 = a.fnfn1() </span><br><span class="line">fn1()<span class="comment">// this === window  undefined</span></span><br></pre></td></tr></table></figure>

<ol>
<li>作为构造函数执行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'zhangsan'</span>)</span><br></pre></td></tr></table></figure></li>
<li>作为对象属性执行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	name : <span class="string">'A'</span>,</span><br><span class="line">	fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn() <span class="comment">//A</span></span><br></pre></td></tr></table></figure></li>
<li>作为普通函数执行<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//window</span></span><br></pre></td></tr></table></figure></li>
<li>call apply bind<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	alert(name)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn1.call(&#123;<span class="attr">x</span>:<span class="number">100</span>&#125;,<span class="string">'zhangsan'</span>,<span class="number">20</span>) <span class="comment">// alert &#123;x:100&#125; undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	alert(name)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn2.apply(&#123;<span class="attr">x</span>:<span class="number">100</span>&#125;,[<span class="string">'zhangsan'</span>,<span class="number">20</span>]) <span class="comment">// alert &#123;x:100&#125; undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn3 = <span class="function"><span class="keyword">function</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	alert(name)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;.bind(&#123;<span class="attr">y</span>:<span class="number">100</span>&#125;)</span><br><span class="line">fn3(<span class="string">'zhangsan'</span>,<span class="number">20</span>) <span class="comment">// alert &#123;x:100&#125; undefined</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>没有块级作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br></pre></td></tr></table></figure>

<p>只有函数和全局作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">200</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'fn'</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'global'</span>,a)</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> c= <span class="number">400</span>;</span><br><span class="line">		<span class="built_in">console</span>.log(a)</span><br><span class="line">		<span class="built_in">console</span>.log(b)</span><br><span class="line">		<span class="built_in">console</span>.log(c)</span><br><span class="line">	&#125;</span><br><span class="line">	fn1()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="comment">//返回一个函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(b) <span class="comment">//自由变量，父作用寻找</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = fn()</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span></span><br><span class="line">fn1() <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>场景</p>
<ol>
<li>函数作为返回值</li>
<li>函数作为参数传递<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">200</span>;</span><br><span class="line">	<span class="comment">//返回一个函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(b) <span class="comment">//自由变量，父作用寻找</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = fn()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b =<span class="number">600</span>;</span><br><span class="line">	fn()</span><br><span class="line">&#125;</span><br><span class="line">fn2(fn1) <span class="comment">//200</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>作用域和闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>原型和原型链</title>
    <url>/2020/04/16/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么回去他的<strong>proto</strong>(隐式原型)即他的构造函数prototype（显式原型）中寻找</p>

          </blockquote> 

<a id="more"></a>

<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><ol>
<li><p>如何准确判断一个变量是数组类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个原型链继承的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Elem</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.elem = <span class="built_in">document</span>.getElementById(id)</span><br><span class="line">&#125;</span><br><span class="line">Elem.prototype.html = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> elem = <span class="keyword">this</span>.elem</span><br><span class="line">	<span class="keyword">if</span>(val)&#123;</span><br><span class="line">		elem.innerHML = val</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//链式调用</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> elem.innerHML</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">elem.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type,fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> elem = <span class="keyword">this</span>.elem</span><br><span class="line">	elem.addEventListener(type.fn)</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">//链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div1 = <span class="keyword">new</span> Elem(<span class="string">'div'</span>)</span><br><span class="line">div1.html(<span class="string">'&lt;p&gt;hello word&lt;/p&gt;'</span>)</span><br><span class="line">div1.on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">div1.html(<span class="string">'&lt;p&gt;hello word&lt;/p&gt;'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">'alert'</span>)</span><br><span class="line">&#125;).html(<span class="string">'&lt;p&gt;hello word1&lt;/p&gt;'</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>描述new一个对象的过程</p>
<ol>
<li>创建一个新对象</li>
<li>this指向这个新对象</li>
<li>执行代码，即对this赋值</li>
<li>返回this</li>
</ol>
</li>
<li><p>zepto（或其他框架）源码中如如何使用原型链</p>
</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol>
<li>大写开头的都是构造函数</li>
<li>构造函数类似一个模版</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">	<span class="keyword">this</span>.age = age</span><br><span class="line">	<span class="keyword">this</span>.class = <span class="string">'class-1'</span></span><br><span class="line">	<span class="comment">// return this </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Jvan'</span>,<span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">'Jvan1'</span>,<span class="number">21</span>) <span class="comment">//创建多个</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数-扩展"><a href="#构造函数-扩展" class="headerlink" title="构造函数-扩展"></a>构造函数-扩展</h2><ol>
<li>var a = {} 其实就是var a = new Object()的语法糖</li>
<li>var a = [] 其实就是var a = new Array()的语法糖</li>
<li>function Foo(){…} 其实就是var Foo = new Funciton()的语法糖</li>
<li>用instanceof判断一个函数是否是一个变量的构造函数</li>
</ol>
<h2 id="原型规则和示例"><a href="#原型规则和示例" class="headerlink" title="原型规则和示例"></a>原型规则和示例</h2><p>原型规则是学习原型链的基础</p>
<p>五条原型规则</p>
<ol>
<li><p>所有的引用类型（数组、对象、函数），都具有对象的特性，即可自由扩展属性（null意外）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; obj.a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> arr = []; arr.a = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">fn.a = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有引用类型（数组、对象、函数），都有一个<strong>proto</strong>(隐式原型)属性，属性值是一个普通的对象（null意外）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__)</span><br><span class="line"><span class="built_in">console</span>.log(fn.__proto__)</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有的函数，都有一个属性prototype（显式原型），属性值也是一个普通对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.prototype)</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有引用类型（数组、对象、函数），都有一个<strong>proto</strong>(隐式原型)属性指向他的构造函数的prototype（显式原型）属性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么回去他的<strong>proto</strong>(隐式原型)即他的构造函数prototype（显式原型）中寻找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">funciton Foo(anme)&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.alertName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Foo(<span class="string">'Jvan'</span>)</span><br><span class="line">f.printName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">f.printName();<span class="comment">//自身有</span></span><br><span class="line">f.alertName();<span class="comment">//自身没有从构造函数找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">in</span> f)&#123;</span><br><span class="line">	<span class="comment">//高级浏览器forin屏蔽来自原型的属性</span></span><br><span class="line">	<span class="keyword">if</span>(f.hasOwnProperty(item))&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/assets/yuanxinglian/2020-04-17_00-33-21.png" alt=""></p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p>判断引用类型属于哪个构造函数的方法</p>
<p>f instanceof Foo的判断逻辑是:f的<strong>proto</strong>(隐式原型)一层一层往上，能否对应到Foo.prototype（显式原型）</p>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>原型和原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>变量类型和计算</title>
    <url>/2020/04/16/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>变量类型:值类型（undefined、string、number、boolean）引用类型（object）</p>

          </blockquote> 

<a id="more"></a>

<h1 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h1><ol>
<li><p>js中使用typeof能得到哪些类型<br> 只能区分值类型</p>
<ol>
<li>undefined: undefined </li>
<li>string:    ‘123’</li>
<li>number:    123</li>
<li>object:   {}、[]、null 引用类型</li>
<li>function: console.log</li>
<li>boolean:    true</li>
</ol>
</li>
<li><p>何时使用===何时使用==</p>
<ol>
<li>强等于类型及值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj.a == <span class="literal">null</span>)&#123;</span><br><span class="line">	obj.a === <span class="literal">null</span> || obj === <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>js中有哪些内置函数</p>
<ol>
<li>Object</li>
<li>Array</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Funtion</li>
<li>Date</li>
<li>RegExp</li>
<li>Error<br>内置对象（JSON、Math）</li>
</ol>
</li>
<li><p>js变量按照存储方式区分为哪些类型，并描述特点</p>
<ol>
<li>值类型<br> 值过多会占用内存</li>
<li>引用类型<br> 引用类型包含：对象、数组、函数<br> 可以无限拓展属性</li>
</ol>
</li>
<li><p>如何理解JSON<br> JSON是一个JS对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify()</span><br><span class="line"><span class="built_in">JSON</span>.parse()</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ol>
<li>值类型vs引用类型 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;值类型</span><br><span class="line">var a &#x3D; 100;</span><br><span class="line">var b &#x3D; a; &#x2F;&#x2F;创建了b&#x3D;100</span><br><span class="line">a &#x3D; 200;</span><br><span class="line">console.log(b) &#x2F;&#x2F;100</span><br><span class="line">&#x2F;&#x2F;引用类型 </span><br><span class="line">var a &#x3D; &#123;age:20&#125;</span><br><span class="line">var b &#x3D; a; &#x2F;&#x2F;创建了一个指针</span><br><span class="line">b.age &#x3D; 21;</span><br><span class="line">console.log(a.age) &#x2F;&#x2F; 21</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h2><ol>
<li><p>强制类型转换</p>
<ol>
<li>字符串拼接 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>+<span class="number">10</span> <span class="comment">//110</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span>+<span class="string">'10'</span> <span class="comment">//10010</span></span><br></pre></td></tr></table></figure></li>
<li>== 运算符 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span> == <span class="string">'100'</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="string">''</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == nudefined <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li>if语句 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span>(b)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">''</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span>(a)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>逻辑运算符 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> &amp;&amp; <span class="number">0</span>) <span class="comment">// 0 10=true 0=false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">''</span>|| <span class="string">'abc'</span>) <span class="comment">// 'abc' ''=false 'abc'=true</span></span><br><span class="line"><span class="built_in">console</span>.log(!<span class="built_in">window</span>.abc) <span class="comment">// true window.abc=false !window.abc= true</span></span><br><span class="line"><span class="comment">//判断一个变量会被当成true还是false</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(!!a) <span class="comment">// true a=true !a=false !!a= true</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>typeof运算符详解</p>
</li>
</ol>
]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>变量类型和计算</tag>
      </tags>
  </entry>
  <entry>
    <title>错误监控</title>
    <url>/2020/04/16/%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>代码质量管理其实就是错误监控及代码检查。</p>

          </blockquote> 

<a id="more"></a>

<h1 id="错误监控"><a href="#错误监控" class="headerlink" title="错误监控"></a>错误监控</h1><h2 id="前端错误的分类"><a href="#前端错误的分类" class="headerlink" title="前端错误的分类"></a>前端错误的分类</h2><ol>
<li>即时运行错误：代码错误</li>
<li>资源加载错误</li>
</ol>
<h2 id="错误的捕获方式"><a href="#错误的捕获方式" class="headerlink" title="错误的捕获方式"></a>错误的捕获方式</h2><ol>
<li><p>即时错误的捕获方式</p>
<ol>
<li><p>try..catch</p>
</li>
<li><p>window.onerror</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>,funtion(e)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'捕获'</span>，e)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>资源加载错误</p>
<ol>
<li>object.onerror</li>
<li>performance.getEntries()</li>
<li>Error事件捕获</li>
<li>跨域错误捕获<ol>
<li>错误提示<br> Script error</li>
<li>处理方式<br> 在script标签上增加crossorigin<br> 设置js资源响应头Axxess-COntrol-Allow-Origin:*</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="上报错误的基本原理"><a href="#上报错误的基本原理" class="headerlink" title="上报错误的基本原理"></a>上报错误的基本原理</h2><ol>
<li><p>采用ajax通信方式上报</p>
</li>
<li><p>利用Image对象上报</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src =<span class="string">'http://baidu.com/testjk?r=tksjk'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>代码质量</tag>
        <tag>错误监控</tag>
        <tag>代码检查</tag>
      </tags>
  </entry>
  <entry>
    <title>运行机制</title>
    <url>/2020/04/16/%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>js是单线程，任务分成同步任务、异步任务。先执行同步任务，在执行异步任务。异步任务通过Event-loop实现。同步任务没有执行完成，异步队列不会执行。</p>

          </blockquote> 


<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 3 2</span><br><span class="line"></span><br><span class="line">console.log(1)</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">&#125;,0)</span><br><span class="line">while(true)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(3)</span><br><span class="line">&#x2F;&#x2F; 1 while同步任务，while不断的去循环</span><br><span class="line"></span><br><span class="line">for(var i &#x3D; 0; i &lt; 4; i++)&#123;</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		console.log(i)</span><br><span class="line">	&#125;,1000)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 4 for是一个同步任务。</span><br><span class="line">&#x2F;&#x2F; 异步队列放入时间和执行的时间。setTimeout会等待一秒然后再将函数体放入到异步任务。</span><br></pre></td></tr></table></figure>

<h1 id="任务队列和Event-loop"><a href="#任务队列和Event-loop" class="headerlink" title="任务队列和Event-loop"></a>任务队列和Event-loop</h1><p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<h2 id="JS-调用栈"><a href="#JS-调用栈" class="headerlink" title="JS 调用栈"></a>JS 调用栈</h2><p>JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空</p>
<h2 id="同步任务、异步任务"><a href="#同步任务、异步任务" class="headerlink" title="同步任务、异步任务"></a>同步任务、异步任务</h2><p>JavaScript单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。</p>
<h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p>调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环ss</p>
<h2 id="异步任务触发"><a href="#异步任务触发" class="headerlink" title="异步任务触发"></a>异步任务触发</h2><p>setTimeout和setInterval<br>DOM事件<br>ES6中的Promiss</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>渲染机制</tag>
        <tag>同步任务</tag>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>页面性能</title>
    <url>/2020/04/16/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>资源合并，减少http请求<br>非核心代码一步加载 -&gt; 异步加载的方式 -&gt; 异步加载的区别<br>利用浏览器缓存 -&gt; 缓存的分类  -&gt;  缓存的原理<br>使用CDN<br>与解析DNS</p>

          </blockquote> 

<a id="more"></a>

<h1 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h1><h2 id="提升页面性能的方法"><a href="#提升页面性能的方法" class="headerlink" title="提升页面性能的方法"></a>提升页面性能的方法</h2><ol>
<li>资源合并，减少http请求</li>
<li>非核心代码一步加载 -&gt; 异步加载的方式 -&gt; 异步加载的区别</li>
<li>利用浏览器缓存 -&gt; 缓存的分类  -&gt;  缓存的原理</li>
<li>使用CDN</li>
<li>与解析DNS <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv&#x3D;&quot;x-dns-prefetch-control&quot; content&#x3D;&quot;on&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;dns-prefetch&quot; href&#x3D;&quot;&#x2F;&#x2F;host_name_to_prefetchs.com&quot;&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h2><ol>
<li>异步加载的方式<ol>
<li>动态脚本加载</li>
<li>defer</li>
<li>async</li>
</ol>
</li>
<li>异步加载的区别<ol>
<li>defer是在html解析完后才会执行，如果是多个，按照加载的顺序依次执行</li>
<li>async是在加载完后立即执行，如果是多个，执行顺序与加载顺序无关</li>
</ol>
</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol>
<li>缓存的分类<ol>
<li>强缓存<ol>
<li>Expires过期时间-绝对时间/Cache-Control过期时间-相对时间</li>
</ol>
</li>
<li>协商缓存<ol>
<li>Last-Modified开始时间/If-Modified-Since结束时间</li>
<li>Etag对比hash值/If-None-Match过期强缓存时间</li>
</ol>
</li>
</ol>
</li>
<li>缓存的原理<br> 当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>渲染机制</tag>
        <tag>同步任务</tag>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染机制</title>
    <url>/2020/04/16/%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>HTML经过html Parser转成DOM tree，Style Sheets经过 CSS Parser转成 Style Rules，然后经过整合形成一个Render Tree，需要渲染的结构。Render Tree通过Layout知道元素的位置，然后Painting 绘制出来界面。</p>

          </blockquote> 

<a id="more"></a>

<h1 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h1><h2 id="渲染机制类"><a href="#渲染机制类" class="headerlink" title="渲染机制类"></a>渲染机制类</h2><h3 id="什么是DOCTYPE及作用"><a href="#什么是DOCTYPE及作用" class="headerlink" title="什么是DOCTYPE及作用"></a>什么是DOCTYPE及作用</h3><p>DTD（document type definition，文档类型定义）就是告诉浏览器是什么文档类型，浏览器根据这些来决定用什么类型来解析文件</p>
<p>DOCTYPE就是用来说明文件类型和DTD规范及验证文件合法性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># HTML5</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line"># HTML 4.01 Strict 严格模式 不可以使用弃用元素</span><br><span class="line"></span><br><span class="line"># HTML 4.01 Transitional 宽松模式 可以使用弃用元素</span><br></pre></td></tr></table></figure>
<h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><p><img src="/assets/xuanran/2020-04-16_20-58-46.png" alt=""></p>
<p>HTML经过html Parser转成DOM tree，Style Sheets经过 CSS Parser转成 Style Rules，然后经过整合形成一个Render Tree，需要渲染的结构。Render Tree通过Layout知道元素的位置，然后Painting 绘制出来界面。</p>
<h3 id="重排Reflow"><a href="#重排Reflow" class="headerlink" title="重排Reflow"></a>重排Reflow</h3><p>DOM结构中各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式计算并根据计算结果将元素出现在该出现的地方，这个过程就是reflow</p>
<h4 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">增加，删除、修改DOM会导致Reflow或Repaint</span><br><span class="line">移动位置，动画</span><br><span class="line">修改样式</span><br><span class="line">Resize窗口（移动端不会），滚动</span><br><span class="line">修改默认字体</span><br></pre></td></tr></table></figure>

<p>触发动画的开始不要用diaplay:none属性值，因为它会引起Layout、Paint环节，通过切换类名就已经是一种很好的办法。<br>还有就是，translate属性值来替换top/left/right/bottom的切换，scale属性值替换width/height，opacity属性替换display/visibility等</p>
<h3 id="重绘Repaint"><a href="#重绘Repaint" class="headerlink" title="重绘Repaint"></a>重绘Repaint</h3><p>当各种盒子的位置、大小及其他属性都确定下来后，浏览器就会把这些元素根据各自的特性绘制一遍，于是页面的内容出现了，这个过程就是Repaint</p>
<h4 id="触发-1"><a href="#触发-1" class="headerlink" title="触发"></a>触发</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DOM改动</span><br><span class="line">CSS改动</span><br></pre></td></tr></table></figure>

<p>减少操作，或统一操作可以减少重绘Repaint</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>渲染机制</tag>
        <tag>重排</tag>
        <tag>重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>单线程与异步</title>
    <url>/2020/03/30/%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>js作为单线程语言,对异步是需要的。</p>

          </blockquote>

<a id="more"></a>

<h1 id="单线程和异步"><a href="#单线程和异步" class="headerlink" title="单线程和异步"></a>单线程和异步</h1><pre><code>1. 单线程-只有一个线程，只能做一件事情
2. 原因-避免DOM渲染的冲突
    1. 浏览器需要渲染DOM
    2. js可以修改DOM结构
    3. js执行的时候，浏览器DOM渲染会暂停
    4. 两段js不能同时执行（都修改DOM就会冲突）
    5. webworker支持多线程，但是不能访问DOM（h5）
3. 解决方案-异步
    1. 没按照书写方式执行，可读性差
    2. callback中不容易模块化</code></pre><h1 id="event-loop"><a href="#event-loop" class="headerlink" title="event-loop"></a>event-loop</h1><pre><code>* 事件轮训、事件循环,js实现异步的具体解决方案
* 同步代码，直接执行
* 异步函数先放在异步队列中
* 待同步函数执行完毕，轮训执行异步队列的函数</code></pre><h1 id="js解决异步的方案"><a href="#js解决异步的方案" class="headerlink" title="js解决异步的方案"></a>js解决异步的方案</h1><h2 id="Deferred"><a href="#Deferred" class="headerlink" title="$.Deferred()"></a>$.Deferred()</h2><pre><code>* 无法改变js异步和单线程的本质
* 只能从写法上杜绝callback的形式
* 他是一种语法糖，但是解藕代码
* 很好的体现：开放封闭原则(对拓展开发对修改封闭)

如果返回的是一个Deferred，可以在结果态出现后，依旧可以修改结果。
所以最好的场景则是返回一个Promise。

Deferred的api可以分成两类
第一类 Deferred.resolve() Deferred.reject() //操作型
第二类 Deferred.then Deferred.done Deferred.fail //结果型 监听</code></pre><h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><h2 id="async-await的使用"><a href="#async-await的使用" class="headerlink" title="async/await的使用"></a>async/await的使用</h2><pre><code>async/await是一种同步写法
使用await函数必须使用async标示
await必须跟promise实例
需要babel-polyfill(兼容)</code></pre>]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Promise</tag>
        <tag>Deferred</tag>
        <tag>异步</tag>
        <tag>async/await</tag>
        <tag>callback hell</tag>
      </tags>
  </entry>
  <entry>
    <title>Class与js构造函数的区别</title>
    <url>/2020/03/30/Class%E4%B8%8Ejs%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>Class本质上是语法糖，使用的prototype</p>

          </blockquote>

<a id="more"></a>

<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ol>
<li>class在语法上更加贴合面向对象的写法</li>
<li>class实现继承更加易读、易理解</li>
<li>适合面向对象的编程习惯人员</li>
<li>本质上是语法糖，使用的prototype</li>
</ol>
<h1 id="Js构造函数"><a href="#Js构造函数" class="headerlink" title="Js构造函数"></a>Js构造函数</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MathHandle</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x= x;</span><br><span class="line">    <span class="keyword">this</span>.y= y;</span><br><span class="line">&#125;</span><br><span class="line">MathHandle.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x+ <span class="keyword">this</span>.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> MathHandle(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>

<h1 id="CLass基本语法"><a href="#CLass基本语法" class="headerlink" title="CLass基本语法"></a>CLass基本语法</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x,y)&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x</span><br><span class="line">        <span class="keyword">this</span>.y = y</span><br><span class="line">    &#125;</span><br><span class="line">    add()&#123;</span><br><span class="line">        conssole.log(<span class="keyword">this</span>.x+<span class="keyword">this</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> MathHandle(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m.add()</span><br></pre></td></tr></table></figure>

<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathHandle</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> MathHandle <span class="comment">// function </span></span><br><span class="line"><span class="comment">// 在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性（__proto__）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型</span></span><br><span class="line"><span class="comment">// prototype  显式原型 </span></span><br><span class="line"><span class="comment">// __proto__  隐形原型</span></span><br><span class="line">MathHandle === MathHandle.prototype.constructor <span class="comment">// true</span></span><br><span class="line">m.__proto__ == MathHandle.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.eat= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.say= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">var</span> hashiqi = <span class="keyword">new</span> A();</span><br><span class="line"><span class="comment">//Class继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name) <span class="comment">//执行父类的constructor</span></span><br><span class="line">        <span class="keyword">this</span>.name= name</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> hashiqi = <span class="keyword">new</span> D(<span class="string">'name'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="/assets/class/15853171871187.jpg" alt=""><br>在js中万物皆对象，方法(Function)是对象，方法的原型（Function.prototype）是对象，对象具有属性（<strong>proto</strong>）称为隐式原型，对象的隐式原型指向构造该对象的构造函数的显式原型。<br>方法(Function)是一个特殊的对象，除了和其他对象一样具有<strong>proto</strong>属性以外，它还有一个自己特有的原型属性(prototype)，这个属性是一个指针，指向原型对象。原型对象也有一个属性叫constructor，这个属性包含一个指针，指向原构造函数。<br>注意：通过Function.prototype.bind方法构造出来的函数没有prototype属性。<br>注意：Object.prototype.这个对象的是个例外，它的<strong>proto</strong>值为null。</p>
]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Class</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>模块化</title>
    <url>/2020/03/30/%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p>

          </blockquote> 

<a id="more"></a>

<h1 id="模块化的定义"><a href="#模块化的定义" class="headerlink" title="模块化的定义"></a>模块化的定义</h1><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起。块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p>
<h2 id="一个模块的组成"><a href="#一个模块的组成" class="headerlink" title="一个模块的组成"></a>一个模块的组成</h2><ul>
<li>数据-&gt;内部的属性</li>
<li>操作数据的行为-&gt;内部的函数</li>
</ul>
<h1 id="模块化的标准"><a href="#模块化的标准" class="headerlink" title="模块化的标准"></a>模块化的标准</h1><ol>
<li>CommonJS</li>
<li>AMD</li>
<li>Es6</li>
</ol>
<h1 id="各个版本模块化的使用"><a href="#各个版本模块化的使用" class="headerlink" title="各个版本模块化的使用"></a>各个版本模块化的使用</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>定义暴露模块 : exports</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.xxx = value</span><br><span class="line"><span class="built_in">module</span>.exports = value</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>引入模块 : require</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'模块名/模块相对路径'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>定义暴露模块: define([依赖模块名], function(){return 模块对象})</p>
</li>
<li><p>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  <span class="comment">//基本路径</span></span><br><span class="line">  baseUrl : <span class="string">'js/'</span>,</span><br><span class="line">  <span class="comment">//标识名称与路径的映射</span></span><br><span class="line">  paths : &#123;</span><br><span class="line">    <span class="string">'模块1'</span> : <span class="string">'modules/模块1'</span>,</span><br><span class="line">    <span class="string">'模块2'</span> : <span class="string">'modules/模块2'</span>,</span><br><span class="line">    <span class="string">'angular'</span> : <span class="string">'libs/angular'</span>,</span><br><span class="line">    <span class="string">'angular-messages'</span> : <span class="string">'libs/angular-messages'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//非AMD的模块</span></span><br><span class="line">  shim : &#123;</span><br><span class="line">    <span class="string">'angular'</span> : &#123;</span><br><span class="line">        exports : <span class="string">'angular'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'angular-messages'</span> : &#123;</span><br><span class="line">        exports : <span class="string">'angular-messages'</span>,</span><br><span class="line">        deps : [<span class="string">'angular'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Es6"><a href="#Es6" class="headerlink" title="Es6"></a>Es6</h2><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><ol>
<li>分别暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>统一暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;fun,fun2&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>默认暴露</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt;&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">improt xxx <span class="keyword">from</span> <span class="string">'./...'</span></span><br><span class="line">xxx()</span><br></pre></td></tr></table></figure>

<h1 id="模块化进化"><a href="#模块化进化" class="headerlink" title="模块化进化"></a>模块化进化</h1><ol>
<li>全局function模式</li>
</ol>
<ul>
<li><p>编码: 全局变量/函数</p>
</li>
<li><p>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>namespace模式</li>
</ol>
<ul>
<li><p>编码: 将数据/行为封装到对象中</p>
</li>
<li><p>解决: 命名冲突(减少了全局变量)</p>
</li>
<li><p>问题: 数据不安全(外部可以直接修改模块内部的数据)</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abc = &#123;</span><br><span class="line">	a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>IIFE模式/增强(匿名闭包)</li>
</ol>
<ul>
<li><p>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</p>
</li>
<li><p>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</p>
</li>
<li><p>引入依赖: 通过函数形参来引入依赖模块</p>
</li>
</ul>
<p>// (function(window, module2){<br>//     var data = ‘atguigu.com’<br>//     function foo() {<br>// 　　        module2.xxx()<br>// 　　     console.log(‘foo()’+data)<br>// 　　 }<br>// 　　 function bar() {<br>//  　　      console.log(‘bar()’+data)<br>// 　　 }<br>// 　　 window.module = {foo}<br>// })(window, module2)</p>
<h1 id="Es6模块化的使用和编译环境"><a href="#Es6模块化的使用和编译环境" class="headerlink" title="Es6模块化的使用和编译环境"></a>Es6模块化的使用和编译环境</h1><ul>
<li>语法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// util</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// util1</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// default</span></span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> ./util.js</span><br><span class="line"><span class="comment">// 多个</span></span><br><span class="line"><span class="keyword">import</span> &#123;fn1,fn2&#125; <span class="keyword">from</span> ./util.js</span><br></pre></td></tr></table></figure>

<ul>
<li>工具</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel</span></span><br><span class="line">babel-core </span><br><span class="line">babel-preset-es2015 </span><br><span class="line">babel-preset-latest</span><br><span class="line"><span class="comment">// webpack</span></span><br><span class="line">webpack</span><br><span class="line">babel-loaders</span><br><span class="line"><span class="comment">// rollup.js</span></span><br><span class="line"><span class="comment">// 压缩的更小 small pieces</span></span><br><span class="line">rollup</span><br><span class="line">rollup-plugin-node-resolve</span><br><span class="line">rollup-plugin-babel</span><br><span class="line">babel-plugin-external-helpers</span><br><span class="line">babel-preset-latest</span><br></pre></td></tr></table></figure>

<p>rollup功能单一，webpack功能强大</p>
<ul>
<li>配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; webpack.config.js</span><br><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[&quot;es2015&quot;,&quot;latest&quot;],</span><br><span class="line">    &quot;plugins&quot;:[]</span><br><span class="line">&#125;s</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    entry:&quot;.&#x2F;src&#x2F;index.js&quot;, &#x2F;&#x2F;入口</span><br><span class="line">    output:&#123; &#x2F;&#x2F;出口</span><br><span class="line">        path:__dirname, &#x2F;&#x2F;地址</span><br><span class="line">        filename:&quot;.&#x2F;build&#x2F;bundle.js&quot; &#x2F;&#x2F;文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    module:&#123; &#x2F;&#x2F;模块</span><br><span class="line">        rules:[ &#x2F;&#x2F;规则</span><br><span class="line">            &#123;</span><br><span class="line">            test:&#x2F;\.js?$&#x2F;, &#x2F;&#x2F;使用规则的文件类型</span><br><span class="line">            exclude:&#39;&#x2F;(node_modules)&#x2F;&#39;, &#x2F;&#x2F;排除</span><br><span class="line">            loader:&#39;babel-loader&#39; &#x2F;&#x2F;使用的规则文件</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rollup</span><br><span class="line">&#x2F;&#x2F; 配置编译环境</span><br><span class="line">&#x2F;&#x2F; .babelrc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;:[</span><br><span class="line">        [&quot;latest&quot;:&#123;</span><br><span class="line">            &quot;es2015&quot;:&#123;</span><br><span class="line">                &quot;modules&quot;:false &#x2F;&#x2F;过滤modules</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;:[&quot;external-helpers&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; rollup.config.js</span><br><span class="line">import babel from &#39;rollup-plugin-babel&#39;</span><br><span class="line">import resolve from &#39;rollup&#x3D;plugin-node-resolve&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">    entry:&#39;src&#x2F;index.js&#39;, &#x2F;&#x2F;入口</span><br><span class="line">    format:&#39;umd&#39;,   &#x2F;&#x2F;引用格式(兼容方式)</span><br><span class="line">    plugins:[   &#x2F;&#x2F;插件</span><br><span class="line">        resolve(),</span><br><span class="line">        babel(&#123;</span><br><span class="line">            exclude:&quot;node_modules&#x2F;**&quot; &#x2F;&#x2F;过滤</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    dest:&#39;build&#x2F;bundle.js&#39;  &#x2F;&#x2F;出口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>通过抓包工具实现线上调试</title>
    <url>/2020/03/26/%E9%80%9A%E8%BF%87%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E7%BA%BF%E4%B8%8A%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
            <p>工具的诞生就是用来解决问题的！当然有时候工具出现的目的并不是单纯为了解决这个问题。但是，他附带的价值却是能解决它。</p>

          </blockquote>


<a id="more"></a>
<p>这是值得思考的，这也是一个开发者必须要去思考的地方。</p>
<p>团队的小伙子一直抱怨。在测试或者交付之后的代码样式，需要开启后端IDE去编辑。</p>
<p>很多初入行的、或者在小团队的前端开发都有过这样的经历。在前后端没有分离的项目中，都是先交付静态界面，然后制成jsp后就需要使用后端的IDE，顺便配置好后端环境才能去调试和修改。</p>
<p>这无疑是痛苦的，成效低且没有任何成就感。而且在学习配置后端环境这种没有意义的学习成本是没有价值的。</p>
<p>需要去思考，这种思考并不是推翻开发模式。这无疑不现实，所以我们只能思考如何如何减负。</p>
<p>在上面所说的前提环境中，哪些是必须的。我们需要整理出来。</p>
<p>当然，修复还是前端去修复。总不能不管，也不能说要后端写业务的去修改样式。</p>
<p>所以，中间的过程中我们应该是可以去除一些过程。</p>
<p>比如，可不可以不用后端的IDE和环境，能不能用线上、运行的或者可访问的地址来做调试，跳过这些复杂和成本高昂的过程。</p>
<p>当然可以，这个时候Charles出现在视野了。让我们跳过熟悉和不停开启后端IDE的过程，回到前端熟悉领域和场地。</p>
<p>首先先明确名词:</p>
<blockquote>
<blockquote>
<p>抓包（packet capture）就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。</p>
</blockquote>
</blockquote>
<p>将运行着的环境资源替换成本地编辑的资源，这就是调试的核心。Charles选择需要替换的资源，选择Map Local，将线上资源替换成本地资源（编译后的资源）。</p>
]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>Charles</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>从新开始</title>
    <url>/2020/03/17/%E4%BB%8E%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<p>试着去记录一些东西，把散碎的支离破碎整理起来。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
